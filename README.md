# АНАЛИЗ ДАННЫХ В РАЗРАБОТКЕ ИГР
Отчет по лабораторной работе #4 выполнил(а):
- Галимуллин Андрей Александрович
- РИ-230932
- Отметка о выполнении заданий (заполняется студентом):

| Задание | Выполнение | Баллы |
| ------ | ------ | ------ |
| Задание 1 | * | 60 |
| Задание 2 | * | 20 |
| Задание 3 | * | 20 |

знак "*" - задание выполнено; знак "#" - задание не выполнено;

Работу проверили:
- к.т.н., доцент Денисов Д.В.
- к.э.н., доцент Панов М.А.
- ст. преп., Фадеев В.О.

[![N|Solid](https://cldup.com/dTxpPi9lDf.thumb.png)](https://nodesource.com/products/nsolid)

[![Build Status](https://travis-ci.org/joemccann/dillinger.svg?branch=master)](https://travis-ci.org/joemccann/dillinger)

Структура отчета

- Данные о работе: название работы, фио, группа, выполненные задания.
- Цель работы.
- Задание 1.
- Код реализации выполнения задания. Визуализация результатов выполнения (если применимо).
- Задание 2.
- Код реализации выполнения задания. Визуализация результатов выполнения (если применимо).
- Задание 3.
- Код реализации выполнения задания. Визуализация результатов выполнения (если применимо).
- Выводы.
- ✨Magic ✨

## Цель работы
Оценить стркутуру и фунционал перцептрона. На его основе реализовать различные логические элементы.


## Задание 1
###  Задание 1: в проекте Unity реализовать перцептрон, который умеет производить вычисления:
OR | дать комментарии о корректности работы

AND | дать комментарии о корректности работы

NAND | дать комментарии о корректности работы

XOR | дать комментарии о корректности работы


Ход работы:
- После анализа лекции, на unity был загружен скрипт перцептрона и реализованы следующие логические элементы (с комментариями).
1) OR | Логическая операция "или" реализована, как показано на скриншотах ниже. Для минимизации количества ошибок (0) достаточно и 4 эпох перцептрона, однако с другой стороны правильную последовательность на тесте в консоль выведет и с 1 ошибкой в последней эпохе. Поэтому и 2/3 эпох может быть достаточно для получения примерных коэффициентов и правильной последовательности на тесте (номинально может хватить и одной эпохи, если перцептрон сразу подберёт правильные значения). При 8 поколений гарантированно будет нулевое количество ошибок. Работа перцептрона при данной линейной функции вполне корректна.
![изображение](https://github.com/user-attachments/assets/f189689e-0982-4cc6-a7fb-9139d7774ebf)
![изображение](https://github.com/user-attachments/assets/5475712c-9b8f-496c-a8e9-7ed8f45d4c15)
![изображение](https://github.com/user-attachments/assets/bf2eb4d2-8d3b-4ae2-b21c-74da529d7413)

2) AND | Логическая операция "и" реализована и работает корректно. В приципе, всё то, что указано выше про "или" относится к "и". Одной ошибки достаточно для верного прохождения теста, 4 эпох хватает для получения нулевого количества ошибок с определённой периодичностью.
![изображение](https://github.com/user-attachments/assets/5508f318-92b9-4e2f-b0c2-269decd2f45a)
![изображение](https://github.com/user-attachments/assets/37523564-eca3-45d2-9715-dc428f918b32)
![изображение](https://github.com/user-attachments/assets/84d6b1fe-b0a2-42f0-b522-70ff35a20f89)

3) NAND | Логическая операция "не и" реализована и работает корректно. Всё так же правильно проходит тест и при 1 ошибке в последней эпохе, четырёх эпох вполне достаточно для нулевого количества ошибок в большинстве случаев.
![изображение](https://github.com/user-attachments/assets/d6534723-e68c-41e6-ad44-06b4904f2e9b)
![изображение](https://github.com/user-attachments/assets/e880935f-30ec-4190-af77-09bca0b8d2eb)

4) XOR | Логическая операция "исключающее ИЛИ" реализована номинально на unity, однако корректно не работает. Ввиду нелинейности фукции "исключающее ИЛИ" перцептрон не может подобрать нужные коэффициенты, определённая часть данных теряется. Минимальное количство ошибок - 3, чего недостаточно для прохождения теста, даже при 20 эпохах результат будет почти таким же, как и при 8. Таким образом перцептрон не подходит для корректной реализации XOR.
![изображение](https://github.com/user-attachments/assets/8efe5a1b-0ff1-4496-abe8-272aba894c56)
![изображение](https://github.com/user-attachments/assets/deea9872-4e84-404f-9cf5-888cf4890f99)



## Задание 2
###  Построить графики зависимости количества эпох от ошибки  обучения. Указать от чего зависит необходимое количество эпох обучения.
- Среднеквадратическое отклонение (СКО)
- Разброс урона оружия
- Вариативность времени отклика игрока (реакция на события)
Ход работы:
- В первую очередь был заменён первый сегмент таблицы "Выстрелов в едю времени" на "Темп стрельбы с учётом перезарядки и объёма магазина", который, как мне кажется, куда лучше отображает скорость стрельбы определённого оружия (в базовом варианте получалось, что револьвер с дробовиком не так сильно уступают другому оружию, хотя у обоих наименьший объём магазина, что ведёт к постоянным перезарядкам). Формула выглядит следующим образом: (1 - Shoot Delay)*(размер магазина)/(время перезарядки). Благодаря такой формуле видно примерно то же, что наблюдается в самой игре (АКМ с ПП имеют наибольшую плотность огня, даже с учётом медленной перезарядки АКМ, в то время как револьвер, дробовик и нож нуждается в олпределённом ребалансе). Пила же имеет и в игре параметр урона 0, как и параметр Shoot Delay, так что считаем её в не таблицы с бесконечными, по сути значениями. С остальными сегментами таблицы, по сути, никаких изменений не проводилось (кроме тех, что указаны в задании 1).
- Под сегментом таблицы "Средний урон" в столбик подсчитан "Разброс урона оружия" (справа от него среднее значение по строке). Ввиду того, что показатели в строке распределены не равномерно разброс может слегка отличаться от реального значения (+/- единица). Найден он был путём вычитания из макимального значения в строке среднего значения.
- Далее под сегментом таблицы "Средний урон" подсчитано среднеквадратическое отклонение урона для всего оружия, которое имеет в этом смылс (исключения - нож и пила). Используется формула из теории вероятности, представленная ниже.
- Попытка подсчёта вариативность отклика же вызвала некоторые трудности. В реалиях геймплея Save RTF вариативности в приципе не так много, что уж до реакции на события. ибо основная механика - стрельба, по каким-то причинам, не подвластна влиянию игрока. Игровой персонаж в любом случае начнёт стрелать из выбранного оружия, а мобы  не перестанут приходить. Проблемы однозначности прокачки я тоже рассматривал в предыдущей работе (хотя забег с макимальной скоростью и пилой показал, что с вампиризмом всё не так однозначно, но игрок в жизни через такой гринд без кода не пролезет). Единственный момент, который можно было бы как-то просчитать, так это экономический вопрос (когда и как игрок покупает новое оружие, например). Однако в этой части тоже есть проблема, что просто не позволит накопить достаточно валюты за забег для этого, описанна она была выше и в прошлой работе. Поэтому с данным пунктом затрудняюсь выдать какую-либо визуализацию.
![изображение](https://github.com/user-attachments/assets/534998d3-bca4-48ab-8da3-8c4354e02dff) ![scale_1200](https://github.com/user-attachments/assets/3b17b372-5f04-4605-8dda-dc839215a462)



## Задание 3
### Построить визуальную модель работы перцептрона на сцене Unity.

- Для построения визуальной модели работы перцептрона на сцене Unity использованы следующий код на C#. Был взят за основу код перцептрона из лекции и модифицирован, в частности, добавлена переменная Cubuc в начале, которая в методе Train изменяется в 0, если количество ошибок в эпохе меньше либо равно единице (как выяснили выше, при данных значениях перцептрон успешно проходит тест). Далее в методе OnTriggerEnter, если Cubuc=0, то при входе в зону триггера объект с перцептроном изменяет свой цвет (на белый и об этом далее). 
![изображение](https://github.com/user-attachments/assets/8c6e1865-be72-4bbe-a43c-226a4f7b067b)
![изображение](https://github.com/user-attachments/assets/ba9cc292-3dee-4eb9-97cb-b3c3bc713830)
![изображение](https://github.com/user-attachments/assets/dc815fe9-f2d5-41a8-9130-abe44ab536e0)
![изображение](https://github.com/user-attachments/assets/8e0a42f9-d38e-43d2-a1d0-48ba1e32f738)







## Выводы

"Удивительный" опыт первой попытки как-то проанализировать оружие в Save RTF через геймплей, конечно, дал результаты похожие на то, что есть в коде, но в то же время были далековаты от правды и пестрели моими домыслами. Однако после публикации исходников таблица начала обретать свой финальный вид (бесконечный урон пилы, ребаланс и тд). Более подробно о ребалансе будет мною описано в задании 3*, а пока лишь добавлю, что была проведена работа с данными в гугл-шаблоне, а так же был написан код на питоне/С# для юнити, основанный на материалах предыдущего задания. И всё даже работает.

| Plugin | README |
| ------ | ------ |
| Dropbox | [plugins/dropbox/README.md][PlDb] |
| GitHub | [plugins/github/README.md][PlGh] |
| Google Drive | [plugins/googledrive/README.md][PlGd] |
| OneDrive | [plugins/onedrive/README.md][PlOd] |
| Medium | [plugins/medium/README.md][PlMe] |
| Google Analytics | [plugins/googleanalytics/README.md][PlGa] |

## Powered by

**BigDigital Team: Denisov | Fadeev | Panov**
